#include "../include/protocol.h"
#include "../include/policy_bin.h" // Auto-generated by host/compiler.py

static uint32_t last_move_ms = 0;
static uint8_t prev_act_id = 0;

#define OP_IF 0x01
#define OP_ACT 0x02
#define OP_DENY 0x03
#define OP_REQUIRE_PREV 0x04
#define OP_END 0xFF

action_t decision_vm(const pkt_t* p) {
    action_t out = {0, 0};
    size_t pc = 0; int steps = 0;
    int cond_failed = 0;

    while (pc < POLICY_LEN && steps++ < 32) {
        uint8_t op = POLICY_BC[pc++];
        
        if (op == OP_IF) {
            uint16_t i = POLICY_BC[pc] | (POLICY_BC[pc+1]<<8); pc+=2;
            uint16_t c = POLICY_BC[pc] | (POLICY_BC[pc+1]<<8); pc+=2;
            cond_failed = 0; // Start of a new rule block
            if (!(p->intent_id == i && p->conf_q15 >= c)) {
                cond_failed = 1;
            }
        } else if (op == OP_REQUIRE_PREV) {
            uint8_t req_act = POLICY_BC[pc++];
            if (prev_act_id != req_act && prev_act_id != 0) {
                // If the previous act doesn't match and isn't 0 (init), fail the condition.
                // In a real scenario we'd track a sequence or allow the current act.
                cond_failed = 1;
            }
        } else if (op == OP_ACT) {
            uint8_t act_id = POLICY_BC[pc++];
            int16_t val = (int16_t)(POLICY_BC[pc] | (POLICY_BC[pc+1]<<8)); pc+=2;
            if (!cond_failed) {
                out.act = act_id;
                out.v0 = val;
                prev_act_id = act_id;
                return out;
            }
        } else if (op == OP_DENY) {
            out.act = 0;
            prev_act_id = 0;
            return out;
        } else if (op == OP_END) {
            break;
        }
    }
    return out;
}

int gate_allow(const action_t* a, const pkt_t* p) {
    if (a->act == 0) return 0; // Explicitly denied
    // Safety Envelope: Rate-limit MOVE to 50Hz (20ms)
    if (a->act == 2) {
        if (p->t_ms - last_move_ms < 20) return 0;
        last_move_ms = p->t_ms;
    }
    return 1;
}
